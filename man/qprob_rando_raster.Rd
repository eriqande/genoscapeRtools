% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/qprob_rando_raster.R
\name{qprob_rando_raster}
\alias{qprob_rando_raster}
\title{return an RGB raster of colors to depict breeding pops on a map}
\usage{
qprob_rando_raster(
  TRB,
  cols,
  alpha = 0.7,
  alpha_scale = NULL,
  scale_min_to = 0,
  abs_thresh = NULL,
  rel_thresh = NULL,
  alpha_exp = 1,
  alpha_chop_max = 255
)
}
\arguments{
\item{TRB}{the raster brick that comes out of tess3Q_map_rasters.  Typically you
will want to name the layers in it before you toss it into this function.}

\item{cols}{a named vector of colors. The names must correspond to the names of TRB.}

\item{alpha}{Transparency value from 0 (totally invisible) to 1 (totally opaque).}

\item{alpha_scale}{a number between 0 and 1 which gets multiplied by the scaled (so the max
is one and the min is the same) max-regions prob values.  This will override the alpha parameter
without a warning.}

\item{scale_min_to}{This lets you scale the minimum values for setting alpha so that in each max area they are
scale_at_min.}

\item{abs_thresh}{the smoothed Q value above which you always give the
cell the color it belongs to.  This is the absolute version, which means that
once the smoothed Q values have been scaled in a focal region, any of them
greater than abs_thresh will effectively be treated as 1s.}

\item{rel_thresh}{Similar to abs_thresh but it does it on a relative basis.  For
example, if you choose .80, then everything between the max and 80% of the way to the
min value in the max focal region will be assigned 1s.}

\item{alpha_chop_max}{After all the scaling and squishing, if any values of alpha (on the 0..255 scale)
are greater than this, then they get set to alpha_chop_max.}
}
\description{
This takes the raster brick that comes out of tess3Q_map_rasters() and
does some rescaling and random sampling to return a raster of colors that
I hope will do a reliable job of representing (in some way) predicted assignment accuracy
over space.  This blends the colors in the intermediate areas by just sampling
pixels of different colors according to the smoothed Q values we get out of
tess3Q_map_rasters().
}
\examples{
data(wifl_stack)
wifl_colors <-  c(
 INW = "#984ea3",
 EST = "#377eb8",
 PNW = "#4daf4a",
 SSW = "#ff7f00",
 SCC = "#ffff33",
 KER = "#e41a1c",
 WMT = "#00ffff")

 rr <- qprob_rando_raster(TRB = wifl_stack, cols = wifl_colors, alpha_scale = 2.0, abs_thresh = 0.0, alpha_exp = 1.45)

}
